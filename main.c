#include <time.h>
#include <stdio.h>
#include <pthread.h> 
#include <errno.h>

//A struct for representing products
//clock_t is used for simplicity
struct Product{
	
	int product_id;
	clock_t birthday;
	int life;
	
};

//The producer function, which will be executed by a pthread
void* producer(int *MAX){
	
}

//The consumer function, which will be executed by a pthread
void* consumer(void *ptr){
	
	
	
}
//Prints all products, used for debugging
void print_all_products(struct Product prods[], int size){
	
	int i = 0;
	for(i = 0; i < size; ++i){
		printf("Product_id: %d\n", prods[i].product_id);
		printf("Birthday: %d\n", prods[i].birthday);
		printf("Life: %d\n\n", prods[i].life);
	}
	
}

//Shared variables required to control the producer/consumer threads
struct Product **the_buffer;
int buffer_val = 0;
int *buffer_index = &buffer_val;
pthread_mutex_t *buffer_mutex;
pthread_cond_t *consumer_cond;
pthread_cond_t *producer_cond;

//Shared varibales that are initiated by the program inputs
int NUMBER_OF_PRODUCERS;
int NUMBER_OF_CONSUMERS;
int TOTAL_NUMBER_OF_PRODUCTS;
int SIZE_OF_QUEUE;
int SCHEDULE_CHOICE;
int VALUE_OF_QUANTUM;
int RNG_SEED;

int main(int argc, char** argv){
	
	/*
	argv[1] = Number of producer threads
	argv[2] = Number of consumer threads
	argv[3] = Total number of products to be generated by producers
	argv[4] = Size of the queue in which producers and consumers produce and consume (0 = infinite)
	argv[5] = 0 = First-come-first-serve, 1 = Round-Robin
	argv[6] = Value of quantum for round-robin
	argv[7] = Seed for RNG
	
	Conversion from string to int: int = atoi(string)
	*/
	
	int i = 0; //A loop variable, used several times
	
	//Handles the arguemnts passed to the program
	NUMBER_OF_PRODUCERS = atoi(argv[1]);
	NUMBER_OF_CONSUMERS = atoi(argv[2]);
	TOTAL_NUMBER_OF_PRODUCTS = atoi(argv[3]);
	SIZE_OF_QUEUE = atoi(argv[4]);
	SCHEDULE_CHOICE = atoi(argv[5]);
	VALUE_OF_QUANTUM = atoi(argv[6]);
	RNG_SEED = atoi(argv[7]);
	
	srand(RNG_SEED); //Seeds the random number generator with the specified value
	
	//Creates a product array products which holds the products to be produced
	//Populates them with values
	struct Product products[TOTAL_NUMBER_OF_PRODUCTS];
	for(i = 0; i < TOTAL_NUMBER_OF_PRODUCTS; ++i){
		
		products[i].product_id = i;
		products[i].birthday = clock();
		products[i].life = rand() % 1024;
		
	}
	
	return 0;
}


/*
#define NUMBER_OF_PHIL 5

pthread_mutex_t fork_mutex[NUMBER_OF_PHIL];
pthread_cond_t empty = PTHREAD_COND_INITIALIZER;
pthread_mutex_t not3;
int MAX = 3;
int eating = 0;
int waiting = 0;
/*
main()  
{
  int i;
  pthread_t diner_thread[NUMBER_OF_PHIL]; 
  int dn[NUMBER_OF_PHIL];
  void *diner();
  

  pthread_mutex_init(&not3, NULL);

  for (i=0;i<NUMBER_OF_PHIL;i++)
    pthread_mutex_init(&fork_mutex[i], NULL);
  
  for (i=0;i<NUMBER_OF_PHIL;i++){
    dn[i] = i;
    pthread_create(&diner_thread[i],NULL,diner,&dn[i]);
  }
  for (i=0;i<NUMBER_OF_PHIL;i++)
    pthread_join(diner_thread[i],NULL);
  pthread_exit(0);

}

void *diner(int *i)
{
  int v;
  int t = 0;
  printf("I'm diner %d\n",*i);
  v = *i;
  while (t < 5) {

 
    printf("%d is thinking\n", v);
    sleep( v/2);
    printf("%d is hungry\n", v);
    printf("Eating = %i\n" , eating);
    printf("Waiting = %i\n" , waiting);
      
  
    
     pthread_mutex_lock(&not3);    
 
    while(eating >= MAX) {
      printf("max reached\n");
      printf("Eating = %i\n" , eating);
      printf("Waiting = %i\n" , waiting);
      pthread_cond_wait(&empty,&not3);
    }
 
    eating++;

    pthread_mutex_unlock(&not3);

    pthread_mutex_lock(&fork_mutex[v]);
    pthread_mutex_lock(&fork_mutex[(v+1)%NUMBER_OF_PHIL]);
    printf("%d is eating\n", v);
    printf("Eating = %i\n" , eating);
    printf("Waiting = %i\n" , waiting);
  
    if(--eating < MAX)
      pthread_cond_signal(&empty);
   
    t++;
    sleep(1);
    
    printf("%d is done eating\n", v);    
    printf("Eating = %i\n" , eating);
    printf("Waiting = %i\n" , waiting);
      
    pthread_mutex_unlock(&fork_mutex[v]);
    pthread_mutex_unlock(&fork_mutex[(v+1)%NUMBER_OF_PHIL]);
 
  }
  printf("\n%d IS LEAVING\n\n", v);
  pthread_exit(NULL);
}
 
*/